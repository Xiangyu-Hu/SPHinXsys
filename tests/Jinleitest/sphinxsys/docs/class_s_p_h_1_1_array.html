<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SPHinXsys: SPH::Array&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SPHinXsys
   &#160;<span id="projectnumber">alpha version</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_s_p_h.html">SPH</a></li><li class="navelem"><a class="el" href="class_s_p_h_1_1_array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_s_p_h_1_1_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SPH::Array&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="array_8h_source.html">array.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f55f554849fbf6e383296843712efab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a0f55f554849fbf6e383296843712efab">Array</a> (const T &amp;aDefaultValue=T(), int aSize=0, int aCapacity=Array_CAPMIN)</td></tr>
<tr class="memdesc:a0f55f554849fbf6e383296843712efab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a0f55f554849fbf6e383296843712efab">More...</a><br /></td></tr>
<tr class="separator:a0f55f554849fbf6e383296843712efab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e15f488ae2a2a5e47b74188b53af00f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a5e15f488ae2a2a5e47b74188b53af00f">Array</a> (const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>
<tr class="memdesc:a5e15f488ae2a2a5e47b74188b53af00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a5e15f488ae2a2a5e47b74188b53af00f">More...</a><br /></td></tr>
<tr class="separator:a5e15f488ae2a2a5e47b74188b53af00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13615c7285214239f0484cf46a8fead"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#aa13615c7285214239f0484cf46a8fead">~Array</a> ()</td></tr>
<tr class="memdesc:aa13615c7285214239f0484cf46a8fead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa13615c7285214239f0484cf46a8fead">More...</a><br /></td></tr>
<tr class="separator:aa13615c7285214239f0484cf46a8fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba157e5818d4b4222c062b077d964030"><td class="memItemLeft" align="right" valign="top"><a id="aba157e5818d4b4222c062b077d964030"></a>
<a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#aba157e5818d4b4222c062b077d964030">arrayEquals</a> (const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;aArray) const</td></tr>
<tr class="memdesc:aba157e5818d4b4222c062b077d964030"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-operator version of operator ==. <br /></td></tr>
<tr class="separator:aba157e5818d4b4222c062b077d964030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c36b90a0b559e69c7850e7791794b0f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a5c36b90a0b559e69c7850e7791794b0f">operator[]</a> (int aIndex) const</td></tr>
<tr class="memdesc:a5c36b90a0b559e69c7850e7791794b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the array element at a specified index. This overloaded operator can be used both to set and get element values:  <a href="#a5c36b90a0b559e69c7850e7791794b0f">More...</a><br /></td></tr>
<tr class="separator:a5c36b90a0b559e69c7850e7791794b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79679d423f2d29a81f871c33f5461585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a79679d423f2d29a81f871c33f5461585">operator=</a> (const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>
<tr class="memdesc:a79679d423f2d29a81f871c33f5461585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this array to a specified array. This operator makes a complete copy of the specified array; all member variables are copied. So, the result is two identical, independent arrays.  <a href="#a79679d423f2d29a81f871c33f5461585">More...</a><br /></td></tr>
<tr class="separator:a79679d423f2d29a81f871c33f5461585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ade44554c3fd36477ffd67c18bcc41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a55ade44554c3fd36477ffd67c18bcc41">operator==</a> (const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;aArray) const</td></tr>
<tr class="memdesc:a55ade44554c3fd36477ffd67c18bcc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two arrays are equal.  <a href="#a55ade44554c3fd36477ffd67c18bcc41">More...</a><br /></td></tr>
<tr class="separator:a55ade44554c3fd36477ffd67c18bcc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42969a507590e8c8b9ac41f3420d2ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#ab42969a507590e8c8b9ac41f3420d2ed">computeNewCapacity</a> (int aMinCapacity, int &amp;rNewCapacity)</td></tr>
<tr class="memdesc:ab42969a507590e8c8b9ac41f3420d2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a new capacity that is at least as large as a specified minimum capacity; this method does not change the capacity, it simply computes a new recommended capacity.  <a href="#ab42969a507590e8c8b9ac41f3420d2ed">More...</a><br /></td></tr>
<tr class="separator:ab42969a507590e8c8b9ac41f3420d2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebe58b528b720fe21f426799f47efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a90ebe58b528b720fe21f426799f47efc">ensureCapacity</a> (int aCapacity)</td></tr>
<tr class="memdesc:a90ebe58b528b720fe21f426799f47efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the capacity of this array is at least the specified amount. Note that the newly allocated array elements are not initialized.  <a href="#a90ebe58b528b720fe21f426799f47efc">More...</a><br /></td></tr>
<tr class="separator:a90ebe58b528b720fe21f426799f47efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aef18d09f5176a772a2d57dc0dff014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a0aef18d09f5176a772a2d57dc0dff014">trim</a> ()</td></tr>
<tr class="separator:a0aef18d09f5176a772a2d57dc0dff014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd0fbb23aff061ccd0c458c153ecc77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a1cd0fbb23aff061ccd0c458c153ecc77">getCapacity</a> () const</td></tr>
<tr class="separator:a1cd0fbb23aff061ccd0c458c153ecc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec533dc68f936a6a69b20d2e7413b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a1ec533dc68f936a6a69b20d2e7413b1c">setCapacityIncrement</a> (int aIncrement)</td></tr>
<tr class="memdesc:a1ec533dc68f936a6a69b20d2e7413b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amount by which the capacity is increased when the capacity of of the array in exceeded.  <a href="#a1ec533dc68f936a6a69b20d2e7413b1c">More...</a><br /></td></tr>
<tr class="separator:a1ec533dc68f936a6a69b20d2e7413b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a70842105dab412fe26f39383f27748"><td class="memItemLeft" align="right" valign="top"><a id="a0a70842105dab412fe26f39383f27748"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a0a70842105dab412fe26f39383f27748">getCapacityIncrement</a> () const</td></tr>
<tr class="memdesc:a0a70842105dab412fe26f39383f27748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount by which the capacity is increased. <br /></td></tr>
<tr class="separator:a0a70842105dab412fe26f39383f27748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd769503306a1ee0749ebfb6fe84098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a3dd769503306a1ee0749ebfb6fe84098">setSize</a> (int aSize)</td></tr>
<tr class="separator:a3dd769503306a1ee0749ebfb6fe84098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204d7f808c6067eafb2194e9f0175f4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a204d7f808c6067eafb2194e9f0175f4c">getSize</a> () const</td></tr>
<tr class="memdesc:a204d7f808c6067eafb2194e9f0175f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the array.  <a href="#a204d7f808c6067eafb2194e9f0175f4c">More...</a><br /></td></tr>
<tr class="separator:a204d7f808c6067eafb2194e9f0175f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5370bb547361018d3013c19cf2c4d06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#ad5370bb547361018d3013c19cf2c4d06">size</a> () const</td></tr>
<tr class="separator:ad5370bb547361018d3013c19cf2c4d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73917f48e092c2a252514da80a76a4ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a73917f48e092c2a252514da80a76a4ca">append</a> (const T &amp;aValue)</td></tr>
<tr class="memdesc:a73917f48e092c2a252514da80a76a4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a value onto the array.  <a href="#a73917f48e092c2a252514da80a76a4ca">More...</a><br /></td></tr>
<tr class="separator:a73917f48e092c2a252514da80a76a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae176d3ae769c879d7be41391c0f34eb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#ae176d3ae769c879d7be41391c0f34eb6">append</a> (const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>
<tr class="memdesc:ae176d3ae769c879d7be41391c0f34eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an array of values.  <a href="#ae176d3ae769c879d7be41391c0f34eb6">More...</a><br /></td></tr>
<tr class="separator:ae176d3ae769c879d7be41391c0f34eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6a7517bfb720f3df159d5df7e6d1eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#acf6a7517bfb720f3df159d5df7e6d1eb">append</a> (int aSize, const T *aArray)</td></tr>
<tr class="memdesc:acf6a7517bfb720f3df159d5df7e6d1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an array of values.  <a href="#acf6a7517bfb720f3df159d5df7e6d1eb">More...</a><br /></td></tr>
<tr class="separator:acf6a7517bfb720f3df159d5df7e6d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e1225e9fdbe3f37c4f16032b81fb76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a46e1225e9fdbe3f37c4f16032b81fb76">insert</a> (int aIndex, const T &amp;aValue)</td></tr>
<tr class="memdesc:a46e1225e9fdbe3f37c4f16032b81fb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value into the array at a specified index.  <a href="#a46e1225e9fdbe3f37c4f16032b81fb76">More...</a><br /></td></tr>
<tr class="separator:a46e1225e9fdbe3f37c4f16032b81fb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c604ebec21a6dfd866206b62fe6c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a648c604ebec21a6dfd866206b62fe6c2">remove</a> (int aIndex)</td></tr>
<tr class="memdesc:a648c604ebec21a6dfd866206b62fe6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a value from the array at a specified index.  <a href="#a648c604ebec21a6dfd866206b62fe6c2">More...</a><br /></td></tr>
<tr class="separator:a648c604ebec21a6dfd866206b62fe6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493727030a591fcb8224a738dea1ac51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a493727030a591fcb8224a738dea1ac51">set</a> (int aIndex, const T &amp;aValue)</td></tr>
<tr class="memdesc:a493727030a591fcb8224a738dea1ac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value at a specified index.  <a href="#a493727030a591fcb8224a738dea1ac51">More...</a><br /></td></tr>
<tr class="separator:a493727030a591fcb8224a738dea1ac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6524f2d1e862ea0e73da1ea0b050a2"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a4b6524f2d1e862ea0e73da1ea0b050a2">get</a> ()</td></tr>
<tr class="memdesc:a4b6524f2d1e862ea0e73da1ea0b050a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the low-level array.  <a href="#a4b6524f2d1e862ea0e73da1ea0b050a2">More...</a><br /></td></tr>
<tr class="separator:a4b6524f2d1e862ea0e73da1ea0b050a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81ea5d068e8f5951c162d8ed704a402"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#ac81ea5d068e8f5951c162d8ed704a402">get</a> () const</td></tr>
<tr class="memdesc:ac81ea5d068e8f5951c162d8ed704a402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the low-level array.  <a href="#ac81ea5d068e8f5951c162d8ed704a402">More...</a><br /></td></tr>
<tr class="separator:ac81ea5d068e8f5951c162d8ed704a402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56079ea8cd09f82bf462718e751fd5c2"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a56079ea8cd09f82bf462718e751fd5c2">get</a> (int aIndex) const</td></tr>
<tr class="memdesc:a56079ea8cd09f82bf462718e751fd5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the value at a specified array index.  <a href="#a56079ea8cd09f82bf462718e751fd5c2">More...</a><br /></td></tr>
<tr class="separator:a56079ea8cd09f82bf462718e751fd5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ef7f34525bdc3cd6ad81ef48632c60"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a07ef7f34525bdc3cd6ad81ef48632c60">getLast</a> () const</td></tr>
<tr class="separator:a07ef7f34525bdc3cd6ad81ef48632c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a97a565635ad7d9787d2d441ba0e6c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a51a97a565635ad7d9787d2d441ba0e6c">updLast</a> () const</td></tr>
<tr class="separator:a51a97a565635ad7d9787d2d441ba0e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e04f27e5997221a7d37795a3f4e587"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#ac9e04f27e5997221a7d37795a3f4e587">findIndex</a> (const T &amp;aValue) const</td></tr>
<tr class="separator:ac9e04f27e5997221a7d37795a3f4e587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6293f335e1b9bdc21599222d76b14d7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a6293f335e1b9bdc21599222d76b14d7b">rfindIndex</a> (const T &amp;aValue) const</td></tr>
<tr class="separator:a6293f335e1b9bdc21599222d76b14d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acac68e9be5595c845f00727f60d97562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#acac68e9be5595c845f00727f60d97562">size_</a></td></tr>
<tr class="separator:acac68e9be5595c845f00727f60d97562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c9b9b534c675d9f29c7a0e8b810e72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#ad7c9b9b534c675d9f29c7a0e8b810e72">capacity_</a></td></tr>
<tr class="separator:ad7c9b9b534c675d9f29c7a0e8b810e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb2dab2b98f5d2559fd39eba66e3f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#abbfb2dab2b98f5d2559fd39eba66e3f6">capacityIncrement_</a></td></tr>
<tr class="separator:abbfb2dab2b98f5d2559fd39eba66e3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9961bcd37a4247cbdc4c58eff0e53656"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a9961bcd37a4247cbdc4c58eff0e53656">defaultValue_</a></td></tr>
<tr class="separator:a9961bcd37a4247cbdc4c58eff0e53656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1568c3d36b846f3b88d64f568626ac"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a2c1568c3d36b846f3b88d64f568626ac">array_</a></td></tr>
<tr class="separator:a2c1568c3d36b846f3b88d64f568626ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9de7cd20d4d15367196d207c9628b57b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_h_1_1_array.html#a9de7cd20d4d15367196d207c9628b57b">operator&lt;&lt;</a> (std::ostream &amp;aOut, const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>
<tr class="memdesc:a9de7cd20d4d15367196d207c9628b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the output operator. The output for an array looks like the following:<br />
<br />
.  <a href="#a9de7cd20d4d15367196d207c9628b57b">More...</a><br /></td></tr>
<tr class="separator:a9de7cd20d4d15367196d207c9628b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c389642a8a1db9c03409fcffe715fd"><td class="memItemLeft" align="right" valign="top"><a id="a83c389642a8a1db9c03409fcffe715fd"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;in, <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;out)</td></tr>
<tr class="separator:a83c389642a8a1db9c03409fcffe715fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class SPH::Array&lt; T &gt;</h3>

<p>@ details A class for storing an array of values of type T. The capacity of the class grows as needed. To use this template for a class of type T, class T should implement the following methods: default constructor, copy constructor, assignment operator (=), equality operator (==), and less than operator (&lt;). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0f55f554849fbf6e383296843712efab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f55f554849fbf6e383296843712efab">&#9670;&nbsp;</a></span>Array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::<a class="el" href="class_s_p_h_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aDefaultValue</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aCapacity</em> = <code>Array_CAPMIN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDefaultValue</td><td>Default value of an array element. This value is used to initialize array elements as the size of the array is changed. </td></tr>
    <tr><td class="paramname">aSize</td><td>Initial size of the array. The array elements are initialized to aDefaultValue. </td></tr>
    <tr><td class="paramname">aCapacity</td><td>Initial capacity of the array. The initial capacity is guaranteed to be at least as large as aSize + 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e15f488ae2a2a5e47b74188b53af00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e15f488ae2a2a5e47b74188b53af00f">&#9670;&nbsp;</a></span>Array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::<a class="el" href="class_s_p_h_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aArray</td><td><a class="el" href="class_s_p_h_1_1_array.html">Array</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa13615c7285214239f0484cf46a8fead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13615c7285214239f0484cf46a8fead">&#9670;&nbsp;</a></span>~Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::~<a class="el" href="class_s_p_h_1_1_array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>When the array is deleted, references to elements of this array become invalid. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a73917f48e092c2a252514da80a76a4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73917f48e092c2a252514da80a76a4ca">&#9670;&nbsp;</a></span>append() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a value onto the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aValue</td><td>Value to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New size of the array, or, equivalently, the index to the new first empty element of the array. </dd></dl>

</div>
</div>
<a id="ae176d3ae769c879d7be41391c0f34eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae176d3ae769c879d7be41391c0f34eb6">&#9670;&nbsp;</a></span>append() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an array of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aArray</td><td><a class="el" href="class_s_p_h_1_1_array.html">Array</a> of values to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New size of the array, or, equivalently, the index to the new first empty element of the array. </dd></dl>

</div>
</div>
<a id="acf6a7517bfb720f3df159d5df7e6d1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6a7517bfb720f3df159d5df7e6d1eb">&#9670;&nbsp;</a></span>append() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>aArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an array of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSize</td><td>Size of the array to append. </td></tr>
    <tr><td class="paramname">aArray</td><td><a class="el" href="class_s_p_h_1_1_array.html">Array</a> of values to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New size of the array, or, equivalently, the index to the new first empty element of the array. </dd></dl>

</div>
</div>
<a id="ab42969a507590e8c8b9ac41f3420d2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42969a507590e8c8b9ac41f3420d2ed">&#9670;&nbsp;</a></span>computeNewCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::computeNewCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aMinCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rNewCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a new capacity that is at least as large as a specified minimum capacity; this method does not change the capacity, it simply computes a new recommended capacity. </p>
<p>If the capacity increment is negative, the current capacity is doubled until the computed capacity is greater than or equal to the specified minimum capacity. If the capacity increment is positive, the current capacity increment by this amount until the computed capacity is greater than or equal to the specified minimum capacity. If the capacity increment is zero, the computed capacity is set to the current capacity and false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rNewCapacity</td><td>New computed capacity. </td></tr>
    <tr><td class="paramname">aMinCapacity</td><td>Minimum new computed capacity. The computed capacity is incremented until it is at least as large as aMinCapacity, assuming the capacity increment is not zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the new capacity was increased, false otherwise (i.e., if the capacity increment is set to 0). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_p_h_1_1_array.html#a1ec533dc68f936a6a69b20d2e7413b1c" title="Set the amount by which the capacity is increased when the capacity of of the array in exceeded...">setCapacityIncrement()</a> </dd></dl>

</div>
</div>
<a id="a90ebe58b528b720fe21f426799f47efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ebe58b528b720fe21f426799f47efc">&#9670;&nbsp;</a></span>ensureCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::ensureCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that the capacity of this array is at least the specified amount. Note that the newly allocated array elements are not initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCapacity</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the capacity was successfully obtained, false otherwise. </dd></dl>

</div>
</div>
<a id="ac9e04f27e5997221a7d37795a3f4e587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e04f27e5997221a7d37795a3f4e587">&#9670;&nbsp;</a></span>findIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::findIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aValue</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Linear search for an element matching a given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aValue</td><td>Value to which the array elements are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the array element matching aValue. If there is more than one such elements with the same value the index of the first of these elements is returned. If no match is found, -1 is returned. </dd></dl>

</div>
</div>
<a id="a4b6524f2d1e862ea0e73da1ea0b050a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6524f2d1e862ea0e73da1ea0b050a2">&#9670;&nbsp;</a></span>get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the low-level array. </p>
<dl class="section return"><dt>Returns</dt><dd>Vecder to the low-level array. </dd></dl>

</div>
</div>
<a id="ac81ea5d068e8f5951c162d8ed704a402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81ea5d068e8f5951c162d8ed704a402">&#9670;&nbsp;</a></span>get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the low-level array. </p>
<dl class="section return"><dt>Returns</dt><dd>Vecder to the low-level array. </dd></dl>

</div>
</div>
<a id="a56079ea8cd09f82bf462718e751fd5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56079ea8cd09f82bf462718e751fd5c2">&#9670;&nbsp;</a></span>get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the value at a specified array index. </p>
<p>If the index is negative or passed the end of the array, an exception is thrown.</p>
<p>For faster execution, the array elements can be accessed through the overloaded operator[], which does no bounds checking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the desired array element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const reference to the array element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_s_p_h_1_1_exception.html" title="A class for basic exception functionality. ">Exception</a></td><td>if (aIndex&lt;0)||(aIndex&gt;=size_). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator[]. </dd></dl>

</div>
</div>
<a id="a1cd0fbb23aff061ccd0c458c153ecc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd0fbb23aff061ccd0c458c153ecc77">&#9670;&nbsp;</a></span>getCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::getCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the capacity of this storage instance. </p>

</div>
</div>
<a id="a07ef7f34525bdc3cd6ad81ef48632c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ef7f34525bdc3cd6ad81ef48632c60">&#9670;&nbsp;</a></span>getLast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::getLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the last value in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>Last value in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_s_p_h_1_1_exception.html" title="A class for basic exception functionality. ">Exception</a></td><td>if the array is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a204d7f808c6067eafb2194e9f0175f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204d7f808c6067eafb2194e9f0175f4c">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of the array. </dd></dl>

</div>
</div>
<a id="a46e1225e9fdbe3f37c4f16032b81fb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e1225e9fdbe3f37c4f16032b81fb76">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value into the array at a specified index. </p>
<p>This method is relatively computationally costly since many of the array elements may need to be shifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aValue</td><td>Value to be inserted. </td></tr>
    <tr><td class="paramname">aIndex</td><td>Index at which to insert the new value. All current elements from aIndex to the end of the array are shifted one place in the direction of the end of the array. If the specified index is greater than the current size of the array, the size of the array is increased to aIndex+1 and the intervening new elements are initialized to the default value that was specified at the time of construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the array after the insertion. </dd></dl>

</div>
</div>
<a id="a79679d423f2d29a81f871c33f5461585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79679d423f2d29a81f871c33f5461585">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign this array to a specified array. This operator makes a complete copy of the specified array; all member variables are copied. So, the result is two identical, independent arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aArray</td><td><a class="el" href="class_s_p_h_1_1_array.html">Array</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this array. </dd></dl>

</div>
</div>
<a id="a55ade44554c3fd36477ffd67c18bcc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ade44554c3fd36477ffd67c18bcc41">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aArray</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two arrays are equal. </p>
<p>Two arrays are equal if their contents are equal. That is, each array must be the same length and their corresponding array elements must be equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aArray</td><td><a class="el" href="class_s_p_h_1_1_array.html">Array</a> to be tested as equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if equal, false if not equal. </dd></dl>

</div>
</div>
<a id="a5c36b90a0b559e69c7850e7791794b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c36b90a0b559e69c7850e7791794b0f">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the array element at a specified index. This overloaded operator can be used both to set and get element values: </p>
<div class="fragment"><div class="line">Array&lt;T&gt; array(2);</div><div class="line">T value = array[i];</div><div class="line">array[i] = value;</div></div><!-- fragment --><p>This operator is intended for accessing array elements with as little overhead as possible, so no error checking is performed. The caller must make sure the specified index is within the bounds of the array. If error checking is desired, use <a class="el" href="class_s_p_h_1_1_array.html#a4b6524f2d1e862ea0e73da1ea0b050a2" title="Get a pointer to the low-level array. ">Array::get()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the desired element (0 &lt;= aIndex &lt; size_). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the array element. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_p_h_1_1_array.html#a4b6524f2d1e862ea0e73da1ea0b050a2" title="Get a pointer to the low-level array. ">get()</a>. </dd></dl>

</div>
</div>
<a id="a648c604ebec21a6dfd866206b62fe6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c604ebec21a6dfd866206b62fe6c2">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a value from the array at a specified index. </p>
<p>This method is relatively computationally costly since many of the array elements may need to be shifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the value to remove. All elements from aIndex to the end of the array are shifted one place toward the beginning of the array. If aIndex is less than 0 or greater than or equal to the current size of the array, no element is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the array after the removal. </dd></dl>

</div>
</div>
<a id="a6293f335e1b9bdc21599222d76b14d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6293f335e1b9bdc21599222d76b14d7b">&#9670;&nbsp;</a></span>rfindIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::rfindIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aValue</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Linear search in reverse for an element matching a given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aValue</td><td>Value to which the array elements are compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the array element matching aValue. If there is more than one such elements with the same value the index of the last of these elements is returned. If no match is found, -1 is returned. </dd></dl>

</div>
</div>
<a id="a493727030a591fcb8224a738dea1ac51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493727030a591fcb8224a738dea1ac51">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the array element to be set. It is permissible for aIndex to be past the current end of the array- the capacity will be increased if necessary. Values between the current end of the array and aIndex are not initialized. </td></tr>
    <tr><td class="paramname">aValue</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ec533dc68f936a6a69b20d2e7413b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec533dc68f936a6a69b20d2e7413b1c">&#9670;&nbsp;</a></span>setCapacityIncrement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::setCapacityIncrement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIncrement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the amount by which the capacity is increased when the capacity of of the array in exceeded. </p>
<p>If the specified increment is negative, the capacity is set to double whenever the capacity is exceeded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIncrement</td><td>Desired capacity increment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dd769503306a1ee0749ebfb6fe84098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd769503306a1ee0749ebfb6fe84098">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::setSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the size of the array. This method can be used to either increase or decrease the size of the array. If this size of the array is increased, the new elements are initialized to the default value that was specified at the time of construction.</p>
<p>Note that the size of an array is different than its capacity. The size indicates how many valid elements are stored in an array. The capacity indicates how much the size of the array can be increased without allocated more memory. At all times size &lt;= capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSize</td><td>Desired size of the array. The size must be greater than or equal to zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5370bb547361018d3013c19cf2c4d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5370bb547361018d3013c19cf2c4d06">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alternate name for <a class="el" href="class_s_p_h_1_1_array.html#a204d7f808c6067eafb2194e9f0175f4c" title="Get the size of the array. ">getSize()</a>. </p>

</div>
</div>
<a id="a0aef18d09f5176a772a2d57dc0dff014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aef18d09f5176a772a2d57dc0dff014">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trim the capacity of this array so that it is one larger than the size of this array. This is useful for reducing the amount of memory used by this array. This capacity is kept at one larger than the size so that, for example, an array of characters can be treated as a nullptr terminated string. </p>

</div>
</div>
<a id="a51a97a565635ad7d9787d2d441ba0e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a97a565635ad7d9787d2d441ba0e6c">&#9670;&nbsp;</a></span>updLast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::updLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get writable reference to last value in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>writable reference to Last value in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_s_p_h_1_1_exception.html" title="A class for basic exception functionality. ">Exception</a></td><td>if the array is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9de7cd20d4d15367196d207c9628b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de7cd20d4d15367196d207c9628b57b">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>aOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_p_h_1_1_array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the output operator. The output for an array looks like the following:<br />
<br />
. </p>
<p>T[0] T[1] T[2] ... T[size-1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aOut</td><td>Output stream. </td></tr>
    <tr><td class="paramname">aArray</td><td><a class="el" href="class_s_p_h_1_1_array.html">Array</a> to be output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2c1568c3d36b846f3b88d64f568626ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1568c3d36b846f3b88d64f568626ac">&#9670;&nbsp;</a></span>array_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::array_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_s_p_h_1_1_array.html">Array</a> of values. </p>

</div>
</div>
<a id="ad7c9b9b534c675d9f29c7a0e8b810e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c9b9b534c675d9f29c7a0e8b810e72">&#9670;&nbsp;</a></span>capacity_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::capacity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Current capacity of the array. </p>

</div>
</div>
<a id="abbfb2dab2b98f5d2559fd39eba66e3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfb2dab2b98f5d2559fd39eba66e3f6">&#9670;&nbsp;</a></span>capacityIncrement_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::capacityIncrement_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Increment by which the current capacity is increased when the capacity of this storage instance is reached. If negative, capacity doubles. </p>

</div>
</div>
<a id="a9961bcd37a4247cbdc4c58eff0e53656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9961bcd37a4247cbdc4c58eff0e53656">&#9670;&nbsp;</a></span>defaultValue_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::defaultValue_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default value of elements. </p>

</div>
</div>
<a id="acac68e9be5595c845f00727f60d97562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac68e9be5595c845f00727f60d97562">&#9670;&nbsp;</a></span>size_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_p_h_1_1_array.html">SPH::Array</a>&lt; T &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size of the array. Also the index of the first empty array element. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SPHINXsys/src/shared/simbody_sphinxsys/<a class="el" href="array_8h_source.html">array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
